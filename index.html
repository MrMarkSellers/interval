<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interval Trainer — iOS Styled (Firefox-safe)</title>
<style>
:root{--bg:#f2f2f7;--panel:#fff;--radius:18px;--accent:#007aff;--danger:#ff3b30;--text:#1c1c1e}
body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);margin:0;padding:16px;color:var(--text)}
h1{text-align:center;font-weight:700}
.panel{background:var(--panel);border-radius:var(--radius);padding:16px;margin-bottom:16px;box-shadow:0 2px 6px rgba(0,0,0,0.06)}
button{padding:12px 18px;border:none;border-radius:12px;font-size:16px}
.primary{background:var(--accent);color:#fff}
.danger{background:var(--danger);color:#fff}
input,select{padding:12px;font-size:16px;border-radius:12px;border:1px solid #ccc;width:100%;box-sizing:border-box}
#timeline .item{padding:12px;background:#f8f8f8;border-radius:12px;margin-bottom:10px;display:flex;justify-content:space-between;align-items:center}
.drag{cursor:grab;font-size:20px;margin-left:10px}
#radial{width:160px;height:160px;margin:20px auto;position:relative}
#radial svg{transform:rotate(-90deg)}
#radial circle{fill:none;stroke-width:14;stroke-linecap:round}
#radial .bg{stroke:#eee}
#radial .progress{stroke:var(--accent);transition:stroke-dashoffset 1s linear}
#radial .time{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:32px;font-weight:700}
#mediaDisplay img,#mediaDisplay video{max-width:100%;max-height:70vh;display:block;margin:0 auto;border-radius:12px}
.small-note{font-size:13px;color:#666;margin-top:8px}
</style>
</head>
<body>
<h1>Interval Trainer</h1>

<div class="panel">
  <label>Duration per Interval</label><br>
  <select id="duration">
    <option value="30">30 sec</option>
    <option value="45">45 sec</option>
    <option value="60">60 sec</option>
  </select><br><br>

  <label>Repetitions</label>
  <input id="reps" type="number" min="1" max="10" value="1" />
</div>

<div class="panel">
  <h2>Media Items</h2>
  <!-- Hidden native file input. We'll open it programmatically and handle change safely. -->
  <input type="file" id="fileInput" accept="image/*,video/*" style="display:none" />
  <div style="display:flex;gap:10px">
    <button id="chooseBtn" class="primary">Choose File</button>
    <button id="addBtn" class="primary">Add Media</button>
  </div>
  <div id="chosenName" class="small-note">No file chosen</div>

  <h3 style="margin-top:16px">Timeline</h3>
  <div id="timeline"></div>
</div>

<div class="panel">
  <h2>Save Sequence</h2>
  <input id="seqName" placeholder="Sequence Name" /><br><br>
  <button class="primary" onclick="saveSequence()">Save Sequence</button>
  <h3 style="margin-top:16px">Saved</h3>
  <div id="sequenceList"></div>
</div>

<div id="playback" class="panel" style="display:none;text-align:center">
  <h2 id="playbackTitle"></h2>
  <div id="repInfo"></div>
  <div id="radial">
    <svg width="160" height="160">
      <circle class="bg" cx="80" cy="80" r="70"></circle>
      <circle class="progress" cx="80" cy="80" r="70"></circle>
    </svg>
    <div class="time" id="timeText"></div>
  </div>
  <div id="mediaDisplay"></div>
  <br>
  <button class="danger" onclick="stopPlayback()">Stop</button>
</div>

<script>
/**********************************************************************
 * Robust single-file Interval Trainer with Firefox-safe file handling
 * - Uses IndexedDB to persist media blobs
 * - Uses an explicit file chooser + state variable for the selected file
 * - Ensures DB is fully opened (Promise-based) before any transactions
 **********************************************************************/

let db;
let selectedFile = null; // holds current file chosen by user until added
let items = []; // timeline items: {id, name, type}
let sequences = JSON.parse(localStorage.getItem('sequences') || '[]');
let timer = null, currentIndex = 0, timeLeft = 0, currentSequence = null;
let dragIndex = null;

// ---------------- IndexedDB (promise-based, Firefox-friendly) ----------------
function openDB(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open('IntervalTrainerDB', 1);
    req.onupgradeneeded = e => {
      const d = e.target.result;
      if(!d.objectStoreNames.contains('media')) d.createObjectStore('media',{ keyPath:'id' });
    };
    req.onerror = () => reject(req.error);
    req.onsuccess = e => resolve(e.target.result);
  });
}

async function init(){
  try{
    db = await openDB();
    renderSequenceList();
  }catch(e){
    console.error('DB open failed', e);
    alert('Could not open browser storage. IndexedDB unavailable.');
  }
}
init();

function saveMediaToDB(id, file){
  return new Promise((resolve,reject)=>{
    try{
      const tx = db.transaction(['media'],'readwrite');
      const store = tx.objectStore('media');
      const req = store.put({ id, blob: file, name: file.name, type: file.type });
      req.onsuccess = () => {};
      req.onerror = () => reject(req.error);
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    }catch(err){reject(err)}
  });
}

function getMediaFromDB(id){
  return new Promise((resolve,reject)=>{
    try{
      const tx = db.transaction(['media'],'readonly');
      const store = tx.objectStore('media');
      const req = store.get(id);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    }catch(e){reject(e)}
  });
}

// ---------------- Safe File Input UI wiring ----------------
const fileInput = document.getElementById('fileInput');
const chooseBtn = document.getElementById('chooseBtn');
const addBtn = document.getElementById('addBtn');
const chosenName = document.getElementById('chosenName');

// Open native file picker when user taps Choose
chooseBtn.addEventListener('click', ()=> fileInput.click());

// When user selects a file, store it in `selectedFile` and show name
fileInput.addEventListener('change', e => {
  selectedFile = e.target.files && e.target.files[0] ? e.target.files[0] : null;
  if(selectedFile) chosenName.textContent = `Selected: ${selectedFile.name}`;
  else chosenName.textContent = 'No file chosen';
});

// Add media button uses the selectedFile variable (robust across browsers)
addBtn.addEventListener('click', async ()=>{
  // ensure DB ready
  if(!db){ alert('Storage not ready yet — try again in a moment'); return; }

  const repsEl = document.getElementById('reps');
  const reps = parseInt(repsEl.value) || 1;
  if(items.length >= reps) { alert(`You can only add ${reps} items.`); return; }

  if(!selectedFile){ alert('Please choose a file first.'); return; }

  // create id and save
  const id = cryptoRandomId();
  try{
    await saveMediaToDB(id, selectedFile);
  }catch(err){ console.error('saveMediaToDB error', err); alert('Could not save file.'); return; }

  items.push({ id, name: selectedFile.name || 'Unnamed', type: selectedFile.type && selectedFile.type.startsWith('video') ? 'video' : 'photo' });

  // clear selectedFile and reset UI
  selectedFile = null;
  fileInput.value = '';
  chosenName.textContent = 'No file chosen';

  renderTimeline();
});

// small strong random id (better than simple Math.random for collisions)
function cryptoRandomId(){
  // 16 hex chars
  return ([...crypto.getRandomValues(new Uint8Array(8))].map(b=>b.toString(16).padStart(2,'0')).join(''));
}

// ---------------- Timeline rendering & drag/drop ----------------
function renderTimeline(){
  const timeline = document.getElementById('timeline');
  timeline.innerHTML = items.map((m,i)=>`
    <div class='item' draggable='true' ondragstart='window.__dragIndex=${i}' ondragover='event.preventDefault()' ondrop='window.__dropIndex=${i};window.__handleDrop && window.__handleDrop()'>
      <span>${i+1}. Stage ${i+1} — ${escapeHtml(m.name)}</span>
      <div>
        <button class='danger' onclick='deleteItem(${i})'>Delete</button>
        <span class='drag'>☰</span>
      </div>
    </div>
  `).join('');
}

window.__handleDrop = function(){
  const di = window.__dragIndex; const dropIndex = window.__dropIndex;
  if(typeof di === 'number' && typeof dropIndex === 'number'){
    const moved = items.splice(di,1)[0];
    items.splice(dropIndex,0,moved);
    window.__dragIndex = undefined; window.__dropIndex = undefined;
    renderTimeline();
  }
}

function deleteItem(i){ items.splice(i,1); renderTimeline(); }

// ---------------- Save / Load sequences (localStorage) ----------------
function saveSequence(){
  const name = document.getElementById('seqName').value.trim();
  if(!name) return alert('Please enter a name for the sequence');
  const duration = parseInt(document.getElementById('duration').value) || 30;
  const reps = parseInt(document.getElementById('reps').value) || 1;
  if(items.length !== reps) return alert('Media count must match repetitions');
  sequences.push({ name, duration, items: items.map(i=>({ id:i.id, name:i.name, type:i.type })) });
  localStorage.setItem('sequences', JSON.stringify(sequences));
  renderSequenceList();
}

function deleteSequence(i){ if(!confirm('Delete sequence?')) return; sequences.splice(i,1); localStorage.setItem('sequences', JSON.stringify(sequences)); renderSequenceList(); }

function renderSequenceList(){
  const list = document.getElementById('sequenceList');
  list.innerHTML = sequences.map((s,i)=>`
    <div style='margin:8px 0;'>
      <button class='primary' onclick='startSequence(${i})'>${escapeHtml(s.name)}</button>
      <button class='danger' onclick='deleteSequence(${i})' style='margin-left:8px'>Delete</button>
    </div>
  `).join('');
}

// ---------------- Playback ----------------
function setRadialProgress(fraction){
  const circle = document.querySelector('.progress');
  const radius = 70; const circumference = 2*Math.PI*radius;
  circle.style.strokeDasharray = `${circumference}`;
  const offset = circumference - Math.max(0,Math.min(1,fraction)) * circumference;
  circle.style.strokeDashoffset = offset;
}

async function startSequence(i){
  currentSequence = sequences[i];
  document.getElementById('playback').style.display = 'block';
  items = [...currentSequence.items]; currentIndex = 0; timeLeft = currentSequence.duration;
  updatePlaybackInfo(); await playMedia(items[currentIndex]);
  timer = setInterval(tick,1000);
}

function updatePlaybackInfo(){
  document.getElementById('playbackTitle').textContent = currentSequence.name;
  document.getElementById('repInfo').textContent = `${currentIndex+1} of ${items.length}`;
}

async function tick(){
  document.getElementById('timeText').textContent = timeLeft + 's';
  setRadialProgress(timeLeft / currentSequence.duration);
  if(timeLeft <= 0){
    currentIndex++;
    if(currentIndex >= items.length){ stopPlayback(); alert('Sequence Complete!'); return; }
    timeLeft = currentSequence.duration; updatePlaybackInfo(); await playMedia(items[currentIndex]);
  }
  timeLeft--;
}

async function playMedia(item){
  try{
    const rec = await getMediaFromDB(item.id);
    if(!rec || !rec.blob){ console.error('Missing media record', item.id); alert('Missing media — it may have been removed'); return; }
    const url = URL.createObjectURL(rec.blob);
    const el = document.getElementById('mediaDisplay');
    if(item.type === 'video') el.innerHTML = `<video src='${url}' autoplay loop playsinline webkit-playsinline></video>`;
    else el.innerHTML = `<img src='${url}' alt='${escapeHtml(item.name)}' />`;
  }catch(err){ console.error(err); alert('Error loading media from storage'); }
}

function stopPlayback(){ clearInterval(timer); document.getElementById('playback').style.display = 'none'; }

// small helper to escape HTML in names
function escapeHtml(s){ return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

// initial render
renderTimeline(); renderSequenceList();
</script>
</body>
</html>
